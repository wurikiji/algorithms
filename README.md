# Algorithms

> [The Algorithm Design Manual](https://books.google.co.kr/books/about/The_Algorithm_Design_Manual.html?id=7XUSn0IKQEgC&source=kp_cover&redir_esc=y) 리뷰 및 정리
>
> 언제 완성될지는 아무도 모름, 지나가던 개발자들의 자유 참여 매우 환영

<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->


- [1. 알고리즘 소개](#1-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%86%8C%EA%B0%9C)
  - [1.1 Robot Tour Optimization](#11-robot-tour-optimization)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## 1. 알고리즘 소개

알고리즘이란 무엇일까? 알고리즘이란 특정한 작업의 목적을 달성하기 위한 일련의 절차를 의미한다. 컴퓨터 프로그램에서는 해당 프로그램을 구성하는 절차적 요소들을 알고리즘이라고 할 수 있다.

모든 절차적 요소를 알고리즘이라고 부르는 것은 아니며, 제대로 정의가 되어있는 일반적인 문제를 푸는데 사용되는 것을 알고리즘이라고 한다. 알고리즘상의 문제들은 해당 알고리즘이 정상적으로 동작하는 사례들과 해당 사례들에 알고리즘을 적용했을 때 도출되는 결과물들의 전체 집합으로 정의된다. 문제와 문제에 대한 사례를 구분지어 생각하는것은 알고리즘 문제의 근본이다. 예를들어 정렬 (*sorting*) 으로 정의된 알고리즘상의 문제를 알아보자.

> 문제: 정렬 (*sorting*)
>
> 입력 (적용 대상): a<sub>1</sub> 부터 a<sub>n</sub> 까지 총 n개의 배열
>
> 출력 (결과): a'<sub>1</sub> ≤ a'<sub>2</sub> ≤ ... ≤ a'<sub>n</sub> 을 성립하는 입력 배열의 치환 배열 (요소는 동일하고 순서가 재정의된 배열)

정렬 문제의 사례는 일련의 이름 배열 (`{Mike, Bob, Sally, Jill}`) 이 될 수도 있고, 일련의 수열 (`{154, 245, 568, 324, 654, 324}`) 가 될 수도 있다. 어떠한 문제가 주어졌을 때, 해당 문제가 어떤 일반적인 경우의 문제의 사례가 되는지 결정하는 것이, 그 문제를 풀기위한 알고리즘을 찾는 첫걸음이다.

중복된 설명에 지루할 수 있겠지만, 위의 예제를 통해 알아봤듯이 알고리즘을 다시 쉽게 정리하자면, 주어진 문제에 대한 어떠한 사례들에 대해서도 원하는 결과값을 도출해 낼 수 있는 일련의 절차들을 알고리즘이라고 정의할 수 있다. 하나의 문제를 풀 수 있는 알고리즘은 단 한개가 아닌 여러가지 종류가 있을 수 있다. 예를 들어 정렬 (*sort*) 문제의 경우 삽입 정렬 (*insertion sort*), 선택 정렬 (selection sort) 등의 알고리즘이 같은 문제를 푸는 여러 종류의 알고리즘이 된다. 예를 들어, 삽입 정렬은 배열 첫 요소를 부분집합으로 시작해서, 뒤의 각 요소들을 제 위치에 삽입 시키는 정렬 알고리즘이다. 삽입 정렬의 C 구현체는 아래와 같다. 

```c
void insertion_sort(item s[], int n) {
  int i,j; /* for 순환에서 사용하기 위한 카운터 변수 */
  for (i = 1; i < n; i++) {
    j = i;
    while ((j > 0) && (s[j] < s[j-1])) {
      /* 맞는 자리가 아닐 경우 한칸씩 뒤로 밀어서 insertion 공간 확보 */
      swap(&s[j], &s[j-1]);
      j = j - 1;
    }
  }
}
```

삽입정렬이 수행되는 순서 흐름은 [여기](https://wurikiji.github.io/algorithms/#Insertion-Sort)에서 애니메이션으로 확인할 수 있다. (예제는 INSERTIONSORT 문자열을 정렬)

삽입정렬의 일반성을 확인해보자. 이름에 대한 정렬, 문자에 대한 정렬 또는 숫자에 대한 정렬 모두 적절한 비교 연산자 (`<`) 만 정의 되어 있다면 정상적으로 정렬할 수 있다. 그러므로, 삽입정렬은 정렬이라는 문제에 대해서 가능한 모든 입력들에 대해 원하는 결과값인 정렬된 배열을 도출해 낼 수 있음을 쉽게 확인할 수 있다. 

좋은 알고리즘이라고 불리기 위해서는 3가지 조건이 있다. 첫번째는 정확성 (correct), 두번째는 효율성 (efficient), 세번째는 쉬운 구현 (easy implement) 이다. 3가지를 동시에 갖는 알고리즘을 구현하기 어려운 경우들 많은데, 일반적으로 상용 프로그램에서 사용되는 알고리즘들은 문제에 대해 적절한 답을 출력하고, 프로그램을 너무 느리게만 하지 않으면 사용할만 하다고 판단된다. 정말 최적의 알고리즘을 찾는 상황은 보통 심각한 성능 문제가 발생하거나, 법적인 문제가 발생했을 때이다. 

이번 챕터에서는 단순히 알고리즘의 정확성에 대해서만 초점을 맞추고, 효율성에 대해서는 챕터 2에서 다루도록 한다. 어떤 문제에 대한 알고리즘은 개발했을 때, 해당 알고리즘이 정확한 답변을 출력하는지를 확인하는 것은 쉬운 일이 아니다. 정확한 알고리즘은 보통 정확성에 대한 증명을 같이 제공해야한다. 그 증명에는 해당 알고리즘이 왜 (어떠한 절차에 의해, 어떠한 이유에 의해) 문제의 모든 사례들을 정확한 결과값으로 도출해 내는지에 대한 설명이 포함되야 한다. 이러한 증명에 대해 설명하기 이전에, "보면 명확하잖아" 라는 설명으로는 왜 정확성에 대한 증명이 될 수 없는지에 대해 이야기 해보도록 하자.

### 1.1 Robot Tour Optimization

